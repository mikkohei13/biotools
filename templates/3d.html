<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>3D Data Visualization</title>
    <link rel="stylesheet" href="/static/search.css">
    <style>
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        #canvas-container {
            width: 100%;
            height: 600px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            background: #f8f9fa;
            position: relative;
        }
        
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
        }
        
        .info-panel {
            margin: 20px 0;
            padding: 15px;
            background: #e9ecef;
            border-radius: 8px;
        }
        
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 18px;
        }
        
        .error {
            color: #dc3545;
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .no-data {
            text-align: center;
            padding: 50px;
            color: #6c757d;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>3D Data Visualization</h1>
            <nav style="margin-bottom: 20px;">
                <a href="/simple" class="back-btn">‚Üê Back to Datasets</a>
            </nav>
        </header>
        
        <div id="loading" class="loading" style="display: none;">
            <div class="spinner"></div>
            <span>Loading dataset...</span>
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
        
        <div id="datasetInfo" class="info-panel" style="display: none;">
            <h3>Dataset Information</h3>
            <div id="datasetDetails"></div>
        </div>
        
        <div id="controls" class="controls" style="display: none;">
            <h4>3D Controls</h4>
            <p>Click and drag to rotate the view. Scroll to zoom in/out.</p>
            <div id="pointCount"></div>
        </div>
        
        <div id="canvas-container" style="display: none;">
            <!-- Three.js canvas will be inserted here -->
        </div>
        
        <div id="noData" class="no-data" style="display: none;">
            <p>No dataset found with the specified ID.</p>
            <a href="/simple">Go back to create a dataset</a>
        </div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // IndexedDB setup
        let db;
        let currentDataset = null;
        let scene, camera, renderer, controls;
        let pointCloud;
        
        // Initialize IndexedDB
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('BioToolsDatasets', 1);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve();
                };
                
                request.onupgradeneeded = (event) => {
                    const database = event.target.result;
                    if (!database.objectStoreNames.contains('datasets')) {
                        const store = database.createObjectStore('datasets', { keyPath: 'id' });
                        store.createIndex('timestamp', 'timestamp', { unique: false });
                        store.createIndex('url', 'url', { unique: false });
                        store.createIndex('hash', 'hash', { unique: false });
                    }
                };
            });
        }
        
        // Get dataset ID from URL parameters
        function getDatasetId() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('id');
        }
        
        // Load dataset from IndexedDB
        async function loadDataset(datasetId) {
            try {
                const transaction = db.transaction(['datasets'], 'readonly');
                const store = transaction.objectStore('datasets');
                const request = store.get(datasetId);
                
                return new Promise((resolve) => {
                    request.onsuccess = () => {
                        resolve(request.result || null);
                    };
                    request.onerror = () => {
                        resolve(null);
                    };
                });
            } catch (error) {
                console.error('Error loading dataset:', error);
                return null;
            }
        }
        
        // Parse data points from dataset
        function parseDataPoints(dataset) {
            console.log('Parsing data points from dataset:', dataset);
            const points = [];
            const results = dataset.data.results || [];
            console.log('Number of results to process:', results.length);
            
            let validPoints = 0;
            let invalidPoints = 0;
            
            for (let i = 0; i < results.length; i++) {
                const result = results[i];
                const gathering = result.gathering;
                
                if (gathering && gathering.conversions && gathering.conversions.eurefCenterPoint && gathering.displayDateTime) {
                    const lat = gathering.conversions.eurefCenterPoint.lat;
                    const lon = gathering.conversions.eurefCenterPoint.lon;
                    const year = parseInt(gathering.displayDateTime.substring(0, 4));
                    
                    console.log(`Point ${i}: lat=${lat}, lon=${lon}, year=${year}, dateTime=${gathering.displayDateTime}`);
                    
                    if (!isNaN(year) && lat && lon) {
                        points.push({
                            x: lon,  // X = longitude
                            y: lat,  // Y = latitude  
                            z: year  // Z = year
                        });
                        validPoints++;
                    } else {
                        console.log(`Invalid point ${i}: year=${year}, lat=${lat}, lon=${lon}`);
                        invalidPoints++;
                    }
                } else {
                    console.log(`Missing data for point ${i}:`, {
                        hasGathering: !!gathering,
                        hasConversions: !!(gathering && gathering.conversions),
                        hasEurefCenterPoint: !!(gathering && gathering.conversions && gathering.conversions.eurefCenterPoint),
                        hasDisplayDateTime: !!(gathering && gathering.displayDateTime)
                    });
                    invalidPoints++;
                }
            }
            
            console.log(`Parsed ${validPoints} valid points, ${invalidPoints} invalid points`);
            console.log('Sample points:', points.slice(0, 5));
            return points;
        }
        
        // Initialize Three.js scene
        function initThreeJS() {
            console.log('Initializing Three.js scene');
            const container = document.getElementById('canvas-container');
            
            // Ensure container has dimensions
            if (container.clientWidth === 0 || container.clientHeight === 0) {
                console.log('Container has no dimensions, setting fallback size');
                container.style.width = '800px';
                container.style.height = '600px';
            }
            
            console.log('Container dimensions:', container.clientWidth, 'x', container.clientHeight);
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            console.log('Scene created');
            
            // Camera
            const aspect = container.clientWidth / container.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 10000);
            camera.position.set(1000, 1000, 1000);
            console.log('Camera created at position:', camera.position);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            console.log('Renderer created and added to container');
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            console.log('Ambient light added');
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            console.log('Directional light added');
            
            // Mouse controls for rotation
            let mouseX = 0, mouseY = 0;
            let isMouseDown = false;
            
            function onMouseDown(event) {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
            
            function onMouseUp() {
                isMouseDown = false;
            }
            
            function onMouseMove(event) {
                if (!isMouseDown) return;
                
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                // Rotate camera around the center
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
            
            function onWheel(event) {
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
            }
            
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('wheel', onWheel);
            
            // Handle window resize
            window.addEventListener('resize', () => {
                const width = container.clientWidth;
                const height = container.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });
        }
        
        // Create 3D point cloud
        function createPointCloud(points) {
            console.log('Creating point cloud with', points.length, 'points');
            
            if (pointCloud) {
                scene.remove(pointCloud);
            }
            
            if (points.length === 0) {
                console.log('No points to display');
                return;
            }
            
            // Calculate bounds for scaling
            const bounds = {
                minX: Math.min(...points.map(p => p.x)),
                maxX: Math.max(...points.map(p => p.x)),
                minY: Math.min(...points.map(p => p.y)),
                maxY: Math.max(...points.map(p => p.y)),
                minZ: Math.min(...points.map(p => p.z)),
                maxZ: Math.max(...points.map(p => p.z))
            };
            
            console.log('Data bounds:', bounds);
            
            // Check year distribution
            const yearCounts = {};
            points.forEach(p => {
                yearCounts[p.z] = (yearCounts[p.z] || 0) + 1;
            });
            console.log('Year distribution:', yearCounts);
            
            // Calculate ranges for proportional scaling
            const xRange = bounds.maxX - bounds.minX;
            const yRange = bounds.maxY - bounds.minY;
            const zRange = bounds.maxZ - bounds.minZ;
            
            console.log('Ranges:', { xRange, yRange, zRange });
            
            // Scale coordinates to fit in a reasonable 3D space
            const scale = 1000; // Base scale factor for lat/lon
            const centerX = (bounds.minX + bounds.maxX) / 2;
            const centerY = (bounds.minY + bounds.maxY) / 2;
            const centerZ = (bounds.minZ + bounds.maxZ) / 2;
            
            // Scale Z-axis so that oldest year = 0, newest year = 200
            // This ensures consistent visual scaling regardless of year range
            const zScale = 200 / zRange; // Scale so total range = 200
            
            console.log('Center point:', { centerX, centerY, centerZ });
            console.log('Scale factors:', { xyScale: scale, zScale });
            
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(points.length * 3);
            const colors = new Float32Array(points.length * 3);
            
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const x = (point.x - centerX) / scale;
                const y = (point.y - centerY) / scale;
                const z = (point.z - bounds.minZ) * zScale; // Scale years: oldest=0, newest=200
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // Color based on year (blue to red gradient)
                const yearRatio = (point.z - bounds.minZ) / (bounds.maxZ - bounds.minZ);
                colors[i * 3] = yearRatio; // Red
                colors[i * 3 + 1] = 0.2; // Green
                colors[i * 3 + 2] = 1 - yearRatio; // Blue
                
                if (i < 10) {
                    console.log(`Point ${i}: original(${point.x}, ${point.y}, ${point.z}) -> scaled(${x.toFixed(3)}, ${y.toFixed(3)}, ${z.toFixed(3)})`);
                }
            }
            
            // Log points from different years to verify Z-axis scaling
            const yearSamples = {};
            const years = [...new Set(points.map(p => p.z))].sort();
            console.log('All years in dataset:', years);
            
            for (let i = 0; i < points.length; i++) {
                const year = points[i].z;
                if (!yearSamples[year] && Object.keys(yearSamples).length < 10) {
                    const point = points[i];
                    const x = (point.x - centerX) / scale;
                    const y = (point.y - centerY) / scale;
                    const z = (point.z - centerZ) / zScale;
                    yearSamples[year] = { x, y, z };
                    console.log(`Year ${year} sample: scaled(${x.toFixed(3)}, ${y.toFixed(3)}, ${z.toFixed(3)})`);
                }
            }
            
            // Show some points from the middle and end of the dataset
            console.log('Points from middle of dataset:');
            for (let i = Math.floor(points.length / 2); i < Math.floor(points.length / 2) + 5; i++) {
                const point = points[i];
                const x = (point.x - centerX) / scale;
                const y = (point.y - centerY) / scale;
                const z = (point.z - centerZ) / zScale;
                console.log(`Point ${i} (year ${point.z}): scaled(${x.toFixed(3)}, ${y.toFixed(3)}, ${z.toFixed(3)})`);
            }
            
            // Log Z-axis statistics
            const zValues = Array.from(positions).filter((_, index) => index % 3 === 2); // Get every 3rd value (Z coordinates)
            const minZ = Math.min(...zValues);
            const maxZ = Math.max(...zValues);
            const scaledZRange = maxZ - minZ;
            
            console.log('Z-axis statistics:');
            console.log('  Original year range:', bounds.minZ, 'to', bounds.maxZ, '(range:', bounds.maxZ - bounds.minZ, ')');
            console.log('  Scaled Z range:', minZ.toFixed(3), 'to', maxZ.toFixed(3), '(range:', scaledZRange.toFixed(3), ')');
            console.log('  Z scale factor:', zScale.toFixed(3));
            console.log('  Y range for comparison:', ((bounds.maxY - bounds.minY) / scale).toFixed(3));
            
            // Calculate and log the actual 3D bounds
            const xValues = Array.from(positions).filter((_, index) => index % 3 === 0);
            const yValues = Array.from(positions).filter((_, index) => index % 3 === 1);
            const scaledXRange = Math.max(...xValues) - Math.min(...xValues);
            const scaledYRange = Math.max(...yValues) - Math.min(...yValues);
            
            console.log('3D space bounds:');
            console.log('  X range:', Math.min(...xValues).toFixed(3), 'to', Math.max(...xValues).toFixed(3), '(range:', scaledXRange.toFixed(3), ')');
            console.log('  Y range:', Math.min(...yValues).toFixed(3), 'to', Math.max(...yValues).toFixed(3), '(range:', scaledYRange.toFixed(3), ')');
            console.log('  Z range:', minZ.toFixed(3), 'to', maxZ.toFixed(3), '(range:', scaledZRange.toFixed(3), ')');
            
            // Check if Z values are too similar
            const zVariance = zValues.reduce((sum, z) => sum + Math.pow(z - (minZ + maxZ) / 2, 2), 0) / zValues.length;
            console.log('  Z variance:', zVariance.toFixed(6));
            
            if (zVariance < 0.001) {
                console.warn('WARNING: Z-axis values are very similar - points may appear on same plane');
            }
            
            console.log('Sample scaled positions:', Array.from(positions.slice(0, 15)));
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 15, // Increased size to make points more visible
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            pointCloud = new THREE.Points(geometry, material);
            scene.add(pointCloud);
            
            console.log('Point cloud added to scene:', pointCloud);
            console.log('Scene children count:', scene.children.length);
            
            // Add axes helper
            const axesHelper = new THREE.AxesHelper(500);
            scene.add(axesHelper);
            console.log('Axes helper added');
            
            // Add a test cube to verify Three.js is working
            const testGeometry = new THREE.BoxGeometry(50, 50, 50);
            const testMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const testCube = new THREE.Mesh(testGeometry, testMaterial);
            testCube.position.set(0, 0, 0);
            scene.add(testCube);
            console.log('Test cube added at origin');
            
            // Add bounding box to show data extent
            const boxGeometry = new THREE.BoxGeometry(
                Math.max(...xValues) - Math.min(...xValues),
                Math.max(...yValues) - Math.min(...yValues), 
                Math.max(...zValues) - Math.min(...zValues)
            );
            const boxMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const boundingBox = new THREE.Mesh(boxGeometry, boxMaterial);
            boundingBox.position.set(
                (Math.min(...xValues) + Math.max(...xValues)) / 2,
                (Math.min(...yValues) + Math.max(...yValues)) / 2,
                (Math.min(...zValues) + Math.max(...zValues)) / 2
            );
            scene.add(boundingBox);
            console.log('Bounding box added to show data extent');
            
            // Position camera to view the data
            const dataCenter = {
                x: (Math.min(...xValues) + Math.max(...xValues)) / 2,
                y: (Math.min(...yValues) + Math.max(...yValues)) / 2,
                z: (Math.min(...zValues) + Math.max(...zValues)) / 2
            };
            const maxRange = Math.max(
                Math.max(...xValues) - Math.min(...xValues),
                Math.max(...yValues) - Math.min(...yValues),
                Math.max(...zValues) - Math.min(...zValues)
            );
            
            camera.position.set(
                dataCenter.x + maxRange * 1.5,
                dataCenter.y + maxRange * 1.5,
                dataCenter.z + maxRange * 1.5
            );
            camera.lookAt(dataCenter.x, dataCenter.y, dataCenter.z);
            console.log('Camera positioned to view data center:', dataCenter);
            console.log('Camera position:', camera.position);
            
            // Update info panel
            document.getElementById('pointCount').innerHTML = `
                <strong>Data Points:</strong> ${points.length}<br>
                <strong>X (Longitude):</strong> ${bounds.minX.toFixed(0)} to ${bounds.maxX.toFixed(0)}<br>
                <strong>Y (Latitude):</strong> ${bounds.minY.toFixed(0)} to ${bounds.maxY.toFixed(0)}<br>
                <strong>Z (Year):</strong> ${bounds.minZ} to ${bounds.maxZ}
            `;
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Debug function to log scene state
        function debugScene() {
            console.log('=== SCENE DEBUG ===');
            console.log('Scene children:', scene.children.length);
            console.log('Camera position:', camera.position);
            console.log('Camera rotation:', camera.rotation);
            console.log('Renderer size:', renderer.getSize(new THREE.Vector2()));
            console.log('Point cloud exists:', !!pointCloud);
            if (pointCloud) {
                console.log('Point cloud geometry:', pointCloud.geometry);
                console.log('Point cloud material:', pointCloud.material);
                console.log('Point cloud position count:', pointCloud.geometry.attributes.position.count);
            }
            console.log('==================');
        }
        
        // Display dataset information
        function displayDatasetInfo(dataset) {
            const datasetInfoDiv = document.getElementById('datasetInfo');
            const datasetDetailsDiv = document.getElementById('datasetDetails');
            
            datasetDetailsDiv.innerHTML = `
                <div class="info-item">
                    <strong>Name:</strong> ${dataset.name || 'Unnamed Dataset'}
                </div>
                <div class="info-item">
                    <strong>ID:</strong> <code>${dataset.id}</code>
                </div>
                <div class="info-item">
                    <strong>Created:</strong> ${dataset.created}
                </div>
                <div class="info-item">
                    <strong>URL:</strong> <a href="${dataset.url}" target="_blank">${dataset.url}</a>
                </div>
                <div class="info-item">
                    <strong>Total Records:</strong> ${dataset.data.total || 'N/A'}
                </div>
            `;
            
            datasetInfoDiv.style.display = 'block';
        }
        
        // Show error
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }
        
        // Show loading
        function showLoading() {
            document.getElementById('loading').style.display = 'block';
        }
        
        // Hide loading
        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                await initDB();
                
                const datasetId = getDatasetId();
                if (!datasetId) {
                    showError('No dataset ID provided. Please select a dataset from the Simple Parser page.');
                    hideLoading();
                    return;
                }
                
                showLoading();
                
                const dataset = await loadDataset(datasetId);
                if (!dataset) {
                    document.getElementById('noData').style.display = 'block';
                    hideLoading();
                    return;
                }
                
                currentDataset = dataset;
                displayDatasetInfo(dataset);
                
                // Parse data points
                const points = parseDataPoints(dataset);
                if (points.length === 0) {
                    showError('No valid data points found in the dataset.');
                    hideLoading();
                    return;
                }
                
                // Show 3D container and controls first
                document.getElementById('canvas-container').style.display = 'block';
                document.getElementById('controls').style.display = 'block';
                
                // Wait a moment for the container to be visible, then initialize 3D scene
                setTimeout(() => {
                    initThreeJS();
                    createPointCloud(points);
                }, 100);
                
                // Debug scene state and start animation after initialization
                setTimeout(() => {
                    debugScene();
                    // Start animation
                    animate();
                }, 200);
                
                hideLoading();
                
            } catch (error) {
                console.error('Error initializing 3D page:', error);
                showError('Failed to load dataset');
                hideLoading();
            }
        });
    </script>
</body>
</html>
